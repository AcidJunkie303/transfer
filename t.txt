using System;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// Throttler that allows immediate execution of the first request
/// and subsequent requests only if more than the specified interval has passed.
/// </summary>
public class GridThrottler : IDisposable
{
    private readonly TimeSpan _interval;
    private DateTime _lastExecutionTime = DateTime.MinValue;
    private CancellationTokenSource _currentCancellationTokenSource;
    private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);
    private Task _pendingTask;
    private readonly object _lock = new object();

    public GridThrottler(TimeSpan interval)
    {
        _interval = interval;
    }

    /// <summary>
    /// Executes the action with throttling logic.
    /// First request executes immediately.
    /// Subsequent requests execute immediately if more than interval has passed,
    /// otherwise they are throttled.
    /// </summary>
    public async Task ThrottleAsync(Func<Task> action)
    {
        await _semaphore.WaitAsync();
        
        try
        {
            var now = DateTime.UtcNow;
            var timeSinceLastExecution = now - _lastExecutionTime;

            // First request or more than interval has passed - execute immediately
            if (timeSinceLastExecution >= _interval)
            {
                // Cancel any pending throttled request
                CancelPendingRequest();
                
                _lastExecutionTime = now;
                await action();
                return;
            }

            // Within throttle window - schedule for later
            CancelPendingRequest();
            _currentCancellationTokenSource = new CancellationTokenSource();
            var token = _currentCancellationTokenSource.Token;
            
            // Calculate delay: interval minus time since last execution
            var delay = _interval - timeSinceLastExecution;
            
            _pendingTask = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(delay, token);
                    
                    if (!token.IsCancellationRequested)
                    {
                        await _semaphore.WaitAsync(token);
                        try
                        {
                            if (!token.IsCancellationRequested)
                            {
                                _lastExecutionTime = DateTime.UtcNow;
                                await action();
                            }
                        }
                        finally
                        {
                            _semaphore.Release();
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                    // Expected when cancellation occurs
                }
            }, token);
        }
        finally
        {
            _semaphore.Release();
        }
    }

    private void CancelPendingRequest()
    {
        lock (_lock)
        {
            if (_currentCancellationTokenSource != null && !_currentCancellationTokenSource.IsCancellationRequested)
            {
                _currentCancellationTokenSource.Cancel();
                _currentCancellationTokenSource.Dispose();
                _currentCancellationTokenSource = null;
            }
        }
    }

    public void Dispose()
    {
        CancelPendingRequest();
        _semaphore?.Dispose();
    }
}
